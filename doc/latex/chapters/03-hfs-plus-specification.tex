\section{HFS+ Filesystem Overview}

HFS Plus (HFS+), also known as Mac OS Extended, is Apple's modern filesystem designed to replace HFS. Introduced in Mac OS 8.1 (1998), it addresses HFS limitations while maintaining backward compatibility.

\subsection{Key Improvements over HFS}

\begin{itemize}
    \item \textbf{Unicode filenames}: Full Unicode support (up to 255 UTF-16 characters)
    \item \textbf{Larger volumes}: Up to 8 EB (exabytes) theoretical
    \item \textbf{Larger files}: Up to 8 EB per file
    \item \textbf{Smaller allocation blocks}: More efficient space usage
    \item \textbf{Journaling support}: Optional transaction journal for crash recovery
    \item \textbf{Hard links}: Support for hard links (Mac OS X 10.2+)
    \item \textbf{Symbolic links}: Support for symbolic links
    \item \textbf{Extended attributes}: Arbitrary metadata on files/folders
    \item \textbf{Case sensitivity option}: HFSX variant supports case-sensitive names
\end{itemize}

\subsection{HFS+ Characteristics}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Feature} & \textbf{Specification} \\
\midrule
Maximum volume size & 8 EB (2\textsuperscript{63} bytes) \\
Maximum file size & 8 EB (2\textsuperscript{63} bytes) \\
Filename length & 255 Unicode characters (UTF-16) \\
Date range & January 1, 1904 to February 6, 2040 (Y2K40) \\
Minimum allocation block & 512 bytes \\
Block addressing & 32-bit allocation block numbers \\
Case sensitivity & Case-insensitive (HFS+) or case-sensitive (HFSX) \\
\bottomrule
\end{tabular}
\caption{HFS+ Specifications}
\end{table}

\section{Volume Structure}

HFS+ volumes are structured similarly to HFS but with enhanced metadata structures.

\subsection{Volume Layout}

\begin{table}[h]
\centering
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Location} & \textbf{Name} & \textbf{Description} \\
\midrule
Byte 0 & Reserved & Boot sector (512 bytes) \\
Byte 512 & Reserved & Additional boot area (512 bytes) \\
Byte 1024 & Volume Header & Primary volume metadata \\
... & Allocation Bitmap & Volume space allocation map \\
... & Allocation File & B-tree of allocation bitmap extents \\
... & Extents Overflow File & B-tree of file extent records \\
... & Catalog File & B-tree of all files and folders \\
... & Attributes File & B-tree of extended attributes \\
... & Startup File & Boot loader for non-Mac systems \\
... & Data Area & File contents and special files \\
-1024 & Alternate VH & Backup copy of Volume Header \\
\bottomrule
\end{tabular}
\caption{HFS+ Volume Layout}
\end{table}

\section{Volume Header - Complete Bit-Level Specification}

The Volume Header is the \textbf{most critical structure} in HFS+. Located at byte offset 1024, it is exactly \textbf{512 bytes}.

\subsection{Volume Header Complete Field Map - Every Byte Documented}

\begin{longtable}{llllp{5cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Type} & \textbf{Size} & \textbf{Description} \\
\midrule
\endhead
+0 & signature & uint16 & 2 & \textbf{0x482B} ('H+') or \textbf{0x4858} ('HX') \\
+2 & version & uint16 & 2 & \textbf{4} (HFS+) or \textbf{5} (HFSX) \\
+4 & attributes & uint32 & 4 & Volume attributes (flags, see below) \\
+8 & lastMountedVersion & uint32 & 4 & OS signature that last mounted \\
+12 & journalInfoBlock & uint32 & 4 & Journal info block (0 = no journal) \\
+16 & createDate & uint32 & 4 & Creation date (HFS+ time) \\
+20 & modifyDate & uint32 & 4 & Last modification date \\
+24 & backupDate & uint32 & 4 & Last backup date \\
+28 & checkedDate & uint32 & 4 & Last fsck date \\
+32 & fileCount & uint32 & 4 & Total files on volume \\
+36 & folderCount & uint32 & 4 & Total folders on volume \\
+40 & blockSize & uint32 & 4 & Allocation block size (bytes) \\
+44 & totalBlocks & uint32 & 4 & Total allocation blocks \\
+48 & freeBlocks & uint32 & 4 & Free allocation blocks \\
+52 & nextAllocation & uint32 & 4 & Hint for next allocation \\
+56 & rsrcClumpSize & uint32 & 4 & Default resource fork clump \\
+60 & dataClumpSize & uint32 & 4 & Default data fork clump \\
+64 & nextCatalogID & uint32 & 4 & Next unused Catalog Node ID \\
+68 & writeCount & uint32 & 4 & Volume write count \\
+72 & encodingsBitmap & uint64 & 8 & Text encodings used (64 bits) \\
+80 & finderInfo & uint32[8] & 32 & Finder information \\
+112 & allocationFile & HFSPlusForkData & 80 & Allocation file fork \\
+192 & extentsFile & HFSPlusForkData & 80 & Extents file fork \\
+272 & catalogFile & HFSPlusForkData & 80 & Catalog file fork \\
+352 & attributesFile & HFSPlusForkData & 80 & Attributes file fork \\
+432 & startupFile & HFSPlusForkData & 80 & Startup file fork \\
\bottomrule
\caption{HFS+ Volume Header Structure (512 bytes total)}
\end{longtable}

\textbf{Total size verification}: 2 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 32 + (80*5) = 512 bytes

\subsection{Critical Field Details - Bit-by-Bit}

\subsubsection{signature - Volume Signature (Offset +0, 2 bytes)}

\textbf{HFS+ Standard}: \texttt{0x482B} (big-endian)

\textbf{Byte representation}:
\begin{verbatim}
Offset 1024: 0x48 ('H')
Offset 1025: 0x2B ('+')
\end{verbatim}

\textbf{HFSX Case-Sensitive}: \texttt{0x4858} (big-endian)

\textbf{Byte representation}:
\begin{verbatim}
Offset 1024: 0x48 ('H')
Offset 1025: 0x58 ('X')
\end{verbatim}

\textbf{Validation}:
\begin{itemize}
    \item Must be exactly \texttt{0x482B} or \texttt{0x4858}
    \item Any other value = not HFS+ or corrupted
    \item \texttt{0x4244} = HFS (not HFS+)
\end{itemize}

\textbf{Hex dump verification}:
\begin{verbatim}
xxd -s 1024 -l 2 -p volume.hfsplus
Expected: 482b (HFS+) or 4858 (HFSX)
\end{verbatim}

\subsubsection{version - Volume Version (Offset +2, 2 bytes)}

\textbf{HFS+ Standard}: \texttt{0x0004} (4 decimal, big-endian)

\textbf{Byte representation}:
\begin{verbatim}
Offset 1026: 0x00
Offset 1027: 0x04
\end{verbatim}

\textbf{HFSX}: \texttt{0x0005} (5 decimal)

\textbf{Validation}: mkfs.hfs+ sets version to 4 for standard HFS+.

\subsubsection{attributes - Volume Attributes (Offset +4, 4 bytes)}

32-bit flags field (big-endian). \textbf{Every bit documented}:

\begin{longtable}{llp{7cm}}
\toprule
\textbf{Bit} & \textbf{Hex Mask} & \textbf{Meaning} \\
\midrule
\endhead
0-6 & 0x0000007F & Reserved (must be 0) \\
7 & 0x00000080 & Volume locked by hardware \\
\textbf{8} & \textbf{0x00000100} & \textbf{Volume unmounted cleanly} \\
9 & 0x00000200 & Volume has spared bad blocks \\
10 & 0x00000400 & Needs fsck (consistency check required) \\
11 & 0x00000800 & Catalog node IDs wrapped around \\
12 & 0x00001000 & Software lock \\
\textbf{13} & \textbf{0x00002000} & \textbf{Volume is journaled} \\
14 & 0x00004000 & Reserved \\
15 & 0x00008000 & Reserved \\
16-31 & 0xFFFF0000 & Reserved \\
\bottomrule
\caption{Volume Header attributes Bit Definitions}
\end{longtable}

\textbf{Common values}:
\begin{itemize}
    \item \texttt{0x00000100}: Clean, non-journaled (mkfs.hfs+ default)
    \item \texttt{0x00002100}: Clean, journaled (mkfs.hfs+ -j)
\end{itemize}

\textbf{Byte representation for 0x00000100}:
\begin{verbatim}
Offset 1028: 0x00
Offset 1029: 0x00
Offset 1030: 0x01
Offset 1031: 0x00
\end{verbatim}

\textbf{Verification}:
\begin{verbatim}
xxd -s 1028 -l 4 -p volume.hfsplus
Expected: 00000100 (non-journaled) or 00002100 (journaled)
\end{verbatim}

\subsubsection{blockSize - Allocation Block Size (Offset +40, 4 bytes)}

\textbf{Value}: 32-bit unsigned, big-endian

\textbf{Valid range}:
\begin{itemize}
    \item Minimum: 512 bytes
    \item Maximum: Typically 32 KB, theoretically larger
    \item Must be power of 2
    \item Must be multiple of 512
\end{itemize}

\textbf{Example for 4096 bytes (4 KB)}:
\begin{verbatim}
Decimal: 4096
Hex: 0x00001000
Bytes at offset 1064:
  0x00 0x00 0x10 0x00
\end{verbatim}

\textbf{Validation}:
\begin{verbatim}
xxd -s 1064 -l 4 -p volume.hfsplus
# For 4 KB blocks: 00001000
# For 8 KB blocks: 00002000
\end{verbatim}

\subsubsection{rsrcClumpSize and dataClumpSize (Offsets +56, +60)}

\textbf{Critical}: These MUST be non-zero in valid HFS+ volumes.

\textbf{Recommended value}:
\begin{equation}
\text{clumpSize} = \text{blockSize} \times 4
\end{equation}

For 4 KB blocks:
\begin{equation}
\text{clumpSize} = 4096 \times 4 = 16384 \text{ bytes} = \texttt{0x00004000}
\end{equation}

\textbf{Byte representation}:
\begin{verbatim}
rsrcClumpSize at offset 1080: 0x00 0x00 0x40 0x00
dataClumpSize at offset 1084: 0x00 0x00 0x40 0x00
\end{verbatim}

\textbf{Common error}: If these are 0x00000000, the Volume Header is invalid and nextCatalogID appears at wrong offset.

\textbf{Verification}:
\begin{verbatim}
xxd -s 1080 -l 4 -p volume.hfsplus  # rsrcClumpSize
xxd -s 1084 -l 4 -p volume.hfsplus  # dataClumpSize
# Both should be non-zero
\end{verbatim}

\subsubsection{nextCatalogID - Next CNID (Offset +64, 4 bytes)}

\textbf{Minimum}: \texttt{0x00000010} (16 decimal)

\textbf{Reserved CNIDs 1-15}:
\begin{longtable}{lp{8cm}}
\toprule
\textbf{CNID} & \textbf{Purpose} \\
\midrule
\endhead
1 & Root folder's parent (kHFSRootParentID) \\
2 & Root folder (kHFSRootFolderID) \\
3 & Extents overflow file (kHFSExtentsFileID) \\
4 & Catalog file (kHFSCatalogFileID) \\
5 & Bad allocation blocks file (kHFSBadBlockFileID) \\
6 & Allocation bitmap file (kHFSAllocationFileID) \\
7 & Startup file (kHFSStartupFileID) \\
8 & Attributes file (kHFSAttributesFileID) \\
9-13 & Reserved \\
14 & Journal file (kHFSJournalFileID, if journaled) \\
15 & Journal info block (kHFSJournalInfoBlockID) \\
\bottomrule
\caption{Reserved HFS+ Catalog Node IDs}
\end{longtable}

\textbf{Byte representation for value 16}:
\begin{verbatim}
Offset 1088: 0x00
Offset 1089: 0x00
Offset 1090: 0x00
Offset 1091: 0x10
\end{verbatim}

\textbf{Critical validation}:
\begin{verbatim}
xxd -s 1088 -l 4 -p volume.hfsplus
Expected: 00000010 (minimum value)
\end{verbatim}

\textbf{Common error}: If you see \texttt{00000000}, rsrcClumpSize/dataClumpSize were likely omitted, shifting all subsequent fields.

\subsection{HFSPlusForkData Structure - 80 Bytes Per Fork}

Each fork descriptor is 80 bytes:

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Description} \\
\midrule
\endhead
+0 & logicalSize & File size in bytes (uint64) \\
+8 & clumpSize & Clump size for this file (uint32) \\
+12 & totalBlocks & Total allocation blocks (uint32) \\
+16 & extents[0] & First extent descriptor (8 bytes) \\
+24 & extents[1] & Second extent descriptor (8 bytes) \\
+32 & extents[2] & Third extent descriptor (8 bytes) \\
+40 & extents[3] & Fourth extent descriptor (8 bytes) \\
+48 & extents[4] & Fifth extent descriptor (8 bytes) \\
+56 & extents[5] & Sixth extent descriptor (8 bytes) \\
+64 & extents[6] & Seventh extent descriptor (8 bytes) \\
+72 & extents[7] & Eighth extent descriptor (8 bytes) \\
\bottomrule
\caption{HFSPlusForkData Structure (80 bytes)}
\end{longtable}

\subsubsection{HFSPlusExtentDescriptor - 8 Bytes Each}

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Description} \\
\midrule
\endhead
+0 & startBlock & First allocation block (uint32) \\
+4 & blockCount & Number of blocks (uint32) \\
\bottomrule
\caption{HFSPlusExtentDescriptor (8 bytes)}
\end{longtable}

\textbf{Example}: Catalog file uses blocks 100-199:
\begin{verbatim}
logicalSize:  0x0000000000018800  (100 KB)
clumpSize:    0x00004000          (16 KB)
totalBlocks:  0x00000019          (25 blocks)
extents[0]:   startBlock=100, blockCount=25
              Bytes: 00 00 00 64 00 00 00 19
extents[1-7]: startBlock=0, blockCount=0 (unused)
\end{verbatim}

\subsection{Alternate Volume Header Location}

\textbf{Exact formula}:
\begin{equation}
\text{alt\_VH\_offset} = \text{volume\_size\_bytes} - 1024
\end{equation}

\textbf{Same as HFS}. This is \textbf{NOT} sector-based.

\textbf{Example for 50 MB}:
\begin{verbatim}
Volume size: 52,428,800 bytes
Alt VH at:   52,428,800 - 1,024 = 52,427,776 bytes
\end{verbatim}

\textbf{Verification}:
\begin{verbatim}
FILESIZE=$(stat -c%s volume.hfsplus)
ALTOFFSET=$((FILESIZE - 1024))
xxd -s $ALTOFFSET -l 2 -p volume.hfsplus
Expected: 482b (same as primary)
\end{verbatim}

\section{HFS+ B-Trees}

HFS+ uses B-trees extensively for efficient data organization. All B-trees follow the same structure but contain different record types.

\subsection{B-Tree Structure}

Each B-tree consists of:
\begin{itemize}
    \item \textbf{Header node}: B-tree metadata (first node, index 0)
    \item \textbf{Map nodes}: Allocation bitmap for B-tree nodes
    \item \textbf{Index nodes}: Internal nodes with pointers to child nodes
    \item \textbf{Leaf nodes}: Contain actual data records
\end{itemize}

\subsection{B-Tree Header Record}

Located in the first node of each B-tree:

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Field} & \textbf{Offset} & \textbf{Description} \\
\midrule
\endhead
treeDepth & +0 & Current depth of tree (1-based) \\
rootNode & +2 & Node number of root node \\
leafRecords & +4 & Number of leaf records \\
firstLeafNode & +8 & Node number of first leaf \\
lastLeafNode & +12 & Node number of last leaf \\
nodeSize & +16 & Size of each node (bytes) \\
maxKeyLength & +18 & Maximum key length \\
totalNodes & +20 & Total nodes in tree \\
freeNodes & +24 & Number of free nodes \\
reserved1 & +28 & Reserved \\
clumpSize & +32 & Clump size for file \\
btreeType & +36 & Type of B-tree (0=HFS, 128=HFS+) \\
keyCompareType & +37 & Key comparison method \\
attributes & +38 & B-tree attributes \\
reserved3 & +42 & Reserved (76 bytes) \\
\bottomrule
\caption{B-Tree Header Record}
\end{longtable}

\subsection{Catalog File}

The Catalog File is a B-tree containing all files and folders on the volume.

\subsubsection{Catalog Keys}
\begin{itemize}
    \item \textbf{keyLength}: 2 bytes
    \item \textbf{parentID}: 4 bytes (Parent folder CNID)
    \item \textbf{nodeName}: Variable-length Unicode string
\end{itemize}

\subsubsection{Catalog Record Types}
\begin{enumerate}
    \item \textbf{Folder Record (0x0001)}: Directory metadata
    \item \textbf{File Record (0x0002)}: File metadata and fork information
    \item \textbf{Folder Thread (0x0003)}: Maps CNID to parent folder
    \item \textbf{File Thread (0x0004)}: Maps file CNID to parent folder
\end{enumerate}

\subsubsection{File Record Structure}
\begin{itemize}
    \item recordType: 0x0002
    \item flags: File flags
    \item fileID: Catalog Node ID
    \item createDate, modifyDate: Timestamps
    \item permissions: Unix permissions
    \item userInfo, finderInfo: Finder metadata
    \item textEncoding: Filename encoding hint
    \item dataFork: Fork data for data fork (80 bytes)
    \item resourceFork: Fork data for resource fork (80 bytes)
\end{itemize}

\subsection{Extents Overflow File}

B-tree storing additional extent records when a file's fork exceeds the 8 extents stored in the catalog.

\subsubsection{Extent Key}
\begin{itemize}
    \item keyLength: 2 bytes
    \item forkType: 0x00 (data) or 0xFF (resource)
    \item fileID: Catalog Node ID
    \item startBlock: Starting allocation block
\end{itemize}

\subsubsection{Extent Descriptor}
\begin{itemize}
    \item startBlock: Starting allocation block (4 bytes)
    \item blockCount: Number of contiguous blocks (4 bytes)
\end{itemize}

\subsection{Attributes File}

B-tree storing extended attributes (metadata) for files and folders.

\subsubsection{Supported Attributes}
\begin{itemize}
    \item Extended attributes (xattrs)
    \item Access Control Lists (ACLs)
    \item Resource fork data (if not inline)
    \item Compressed data (HFS+ compression)
\end{itemize}

\section{Journaling}

HFS+ supports optional journaling for filesystem consistency after crashes.

\subsection{Journal Structure}

\begin{itemize}
    \item \textbf{Journal Info Block}: Located at block specified in Volume Header
    \item \textbf{Journal Buffer}: Circular buffer of transactions
    \item \textbf{Transaction Records}: Logged filesystem changes
\end{itemize}

\subsection{Journal Operation}

\begin{enumerate}
    \item \textbf{Begin Transaction}: Start logging changes
    \item \textbf{Log Metadata Changes}: Write changes to journal buffer
    \item \textbf{Commit Transaction}: Mark transaction complete
    \item \textbf{Apply Changes}: Write changes to filesystem
    \item \textbf{Release Transaction}: Free journal space
\end{enumerate}

\subsection{Journal Replay}

After unclean unmount:
\begin{enumerate}
    \item fsck.hfs+ detects journal
    \item Scans journal for uncommitted transactions
    \item Replays committed but unapplied transactions
    \item Marks volume clean
\end{enumerate}

\subsection{Linux Compatibility Warning}

\textbf{CRITICAL}: The Linux HFS+ kernel driver does NOT support journaling.

\begin{itemize}
    \item Journaled volumes may mount read-only automatically
    \item Journal changes are ignored
    \item Risk of data corruption on unclean shutdown
    \item fsck.hfs+ can replay journal, but Linux won't maintain it
\end{itemize}

\textbf{Recommendation}: For Linux systems, create HFS+ volumes without journaling (omit \texttt{-j} option in mkfs.hfs+).

\section{Date Representation}

HFS+ uses 32-bit unsigned integers for dates:
\begin{center}
\textbf{Seconds since January 1, 1904 00:00:00 GMT}
\end{center}

\subsection{Y2K40 Problem}

Maximum date with 32-bit unsigned:
\begin{equation}
1904 + \frac{2^{32}}{365.25 \times 24 \times 3600} \approx \text{February 6, 2040}
\end{equation}

\textbf{Implementation}: hfsutils uses \texttt{hfs\_get\_safe\_time()} to ensure dates stay within valid range.

\section{Unicode Filenames}

HFS+ stores filenames as UTF-16 (fully decomposed).

\subsection{Normalization}

HFS+ uses a special Unicode normalization similar to NFD:
\begin{itemize}
    \item Fully decomposed (e.g., é → e + combining acute)
    \item Case-insensitive comparison (HFS+) or case-sensitive (HFSX)
    \item Maximum 255 UTF-16 code units
\end{itemize}

\subsection{Character Restrictions}

Filenames cannot contain:
\begin{itemize}
    \item Colon (:) - path separator
    \item NULL character
\end{itemize}

\section{HFS+ vs HFSX}

HFSX is a variant of HFS+ with case-sensitive filename comparison.

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Feature} & \textbf{HFS+} & \textbf{HFSX} \\
\midrule
Signature & 0x482B ('H+') & 0x4858 ('HX') \\
Version & 4 & 5 \\
Case sensitivity & No & Yes \\
Filename comparison & Case-insensitive & Case-sensitive \\
"File.txt" = "file.txt" & Yes & No \\
\bottomrule
\end{tabular}
\caption{HFS+ vs HFSX}
\end{table}

\textbf{Note}: hfsutils mkfs.hfs+ creates standard HFS+ volumes (case-insensitive). HFSX support is not currently implemented.

\section{Compatibility Considerations}

\subsection{macOS}
\begin{itemize}
    \item Native support for HFS+ and HFSX
    \item Full journaling support
    \item All extended attributes supported
    \item APFS is now default (macOS 10.13+)
\end{itemize}

\subsection{Linux}
\begin{itemize}
    \item Kernel module \texttt{hfsplus} required
    \item \textbf{No journaling support in kernel driver}
    \item Basic read/write support
    \item Some extended attributes supported
    \item May mount journaled volumes read-only for safety
\end{itemize}

\subsection{FreeBSD/OpenBSD/NetBSD}
\begin{itemize}
    \item Native HFS+ read support
    \item Write support via FUSE
    \item No journaling support
\end{itemize}

\subsection{Windows}
\begin{itemize}
    \item No native HFS+ support
    \item Third-party drivers available (Paragon, MacDrive)
    \item Boot Camp drivers provide read-only access
\end{itemize}
