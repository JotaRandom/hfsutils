\section{HFS+ Filesystem Overview}

HFS Plus (HFS+), also known as Mac OS Extended, is Apple's modern filesystem designed to replace HFS. Introduced in Mac OS 8.1 (1998), it addresses HFS limitations while maintaining backward compatibility.

\subsection{Key Improvements over HFS}

\begin{itemize}
    \item \textbf{Unicode filenames}: Full Unicode support (up to 255 UTF-16 characters)
    \item \textbf{Larger volumes}: Up to 8 EB (exabytes) theoretical
    \item \textbf{Larger files}: Up to 8 EB per file
    \item \textbf{Smaller allocation blocks}: More efficient space usage
    \item \textbf{Journaling support}: Optional transaction journal for crash recovery
    \item \textbf{Hard links}: Support for hard links (Mac OS X 10.2+)
    \item \textbf{Symbolic links}: Support for symbolic links
    \item \textbf{Extended attributes}: Arbitrary metadata on files/folders
    \item \textbf{Case sensitivity option}: HFSX variant supports case-sensitive names
\end{itemize}

\subsection{HFS+ Characteristics}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Feature} & \textbf{Specification} \\
\midrule
Maximum volume size & 8 EB (2\textsuperscript{63} bytes) \\
Maximum file size & 8 EB (2\textsuperscript{63} bytes) \\
Filename length & 255 Unicode characters (UTF-16) \\
Date range & January 1, 1904 to February 6, 2040 (Y2K40) \\
Minimum allocation block & 512 bytes \\
Block addressing & 32-bit allocation block numbers \\
Case sensitivity & Case-insensitive (HFS+) or case-sensitive (HFSX) \\
\bottomrule
\end{tabular}
\caption{HFS+ Specifications}
\end{table}

\section{Volume Structure}

HFS+ volumes are structured similarly to HFS but with enhanced metadata structures.

\subsection{Volume Layout}

\begin{table}[h]
\centering
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Location} & \textbf{Name} & \textbf{Description} \\
\midrule
Byte 0 & Reserved & Boot sector (512 bytes) \\
Byte 512 & Reserved & Additional boot area (512 bytes) \\
Byte 1024 & Volume Header & Primary volume metadata \\
... & Allocation Bitmap & Volume space allocation map \\
... & Allocation File & B-tree of allocation bitmap extents \\
... & Extents Overflow File & B-tree of file extent records \\
... & Catalog File & B-tree of all files and folders \\
... & Attributes File & B-tree of extended attributes \\
... & Startup File & Boot loader for non-Mac systems \\
... & Data Area & File contents and special files \\
-1024 & Alternate VH & Backup copy of Volume Header \\
\bottomrule
\end{tabular}
\caption{HFS+ Volume Layout}
\end{table}

\section{Volume Header - Complete Bit-Level Specification}

The Volume Header is the \textbf{most critical structure} in HFS+. Located at byte offset 1024, it is exactly \textbf{512 bytes}.

\subsection{Volume Header Complete Field Map - Every Byte Documented}

\begin{longtable}{llllp{5cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Type} & \textbf{Size} & \textbf{Description} \\
\midrule
\endhead
+0 & signature & uint16 & 2 & \textbf{0x482B} ('H+') or \textbf{0x4858} ('HX') \\
+2 & version & uint16 & 2 & \textbf{4} (HFS+) or \textbf{5} (HFSX) \\
+4 & attributes & uint32 & 4 & Volume attributes (flags, see below) \\
+8 & lastMountedVersion & uint32 & 4 & OS signature that last mounted \\
+12 & journalInfoBlock & uint32 & 4 & Journal info block (0 = no journal) \\
+16 & createDate & uint32 & 4 & Creation date (HFS+ time) \\
+20 & modifyDate & uint32 & 4 & Last modification date \\
+24 & backupDate & uint32 & 4 & Last backup date \\
+28 & checkedDate & uint32 & 4 & Last fsck date \\
+32 & fileCount & uint32 & 4 & Total files on volume \\
+36 & folderCount & uint32 & 4 & Total folders on volume \\
+40 & blockSize & uint32 & 4 & Allocation block size (bytes) \\
+44 & totalBlocks & uint32 & 4 & Total allocation blocks \\
+48 & freeBlocks & uint32 & 4 & Free allocation blocks \\
+52 & nextAllocation & uint32 & 4 & Hint for next allocation \\
+56 & rsrcClumpSize & uint32 & 4 & Default resource fork clump \\
+60 & dataClumpSize & uint32 & 4 & Default data fork clump \\
+64 & nextCatalogID & uint32 & 4 & Next unused Catalog Node ID \\
+68 & writeCount & uint32 & 4 & Volume write count \\
+72 & encodingsBitmap & uint64 & 8 & Text encodings used (64 bits) \\
+80 & finderInfo & uint32[8] & 32 & Finder information \\
+112 & allocationFile & HFSPlusForkData & 80 & Allocation file fork \\
+192 & extentsFile & HFSPlusForkData & 80 & Extents file fork \\
+272 & catalogFile & HFSPlusForkData & 80 & Catalog file fork \\
+352 & attributesFile & HFSPlusForkData & 80 & Attributes file fork \\
+432 & startupFile & HFSPlusForkData & 80 & Startup file fork \\
\bottomrule
\caption{HFS+ Volume Header Structure (512 bytes total)}
\end{longtable}

\textbf{Total size verification}: 2 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 32 + (80*5) = 512 bytes

\subsection{Critical Field Details - Bit-by-Bit}

\subsubsection{signature - Volume Signature (Offset +0, 2 bytes)}

\textbf{HFS+ Standard}: \texttt{0x482B} (big-endian)

\textbf{Byte representation}:
\begin{verbatim}
Offset 1024: 0x48 ('H')
Offset 1025: 0x2B ('+')
\end{verbatim}

\textbf{HFSX Case-Sensitive}: \texttt{0x4858} (big-endian)

\textbf{Byte representation}:
\begin{verbatim}
Offset 1024: 0x48 ('H')
Offset 1025: 0x58 ('X')
\end{verbatim}

\textbf{Validation}:
\begin{itemize}
    \item Must be exactly \texttt{0x482B} or \texttt{0x4858}
    \item Any other value = not HFS+ or corrupted
    \item \texttt{0x4244} = HFS (not HFS+)
\end{itemize}

\textbf{Hex dump verification}:
\begin{verbatim}
xxd -s 1024 -l 2 -p volume.hfsplus
Expected: 482b (HFS+) or 4858 (HFSX)
\end{verbatim}

\subsubsection{version - Volume Version (Offset +2, 2 bytes)}

\textbf{HFS+ Standard}: \texttt{0x0004} (4 decimal, big-endian)

\textbf{Byte representation}:
\begin{verbatim}
Offset 1026: 0x00
Offset 1027: 0x04
\end{verbatim}

\textbf{HFSX}: \texttt{0x0005} (5 decimal)

\textbf{Validation}: mkfs.hfs+ sets version to 4 for standard HFS+.

\subsubsection{attributes - Volume Attributes (Offset +4, 4 bytes)}

32-bit flags field (big-endian). \textbf{Every bit documented}:

\begin{longtable}{llp{7cm}}
\toprule
\textbf{Bit} & \textbf{Hex Mask} & \textbf{Meaning} \\
\midrule
\endhead
0-6 & 0x0000007F & Reserved (must be 0) \\
7 & 0x00000080 & Volume locked by hardware \\
\textbf{8} & \textbf{0x00000100} & \textbf{Volume unmounted cleanly} \\
9 & 0x00000200 & Volume has spared bad blocks \\
10 & 0x00000400 & Needs fsck (consistency check required) \\
11 & 0x00000800 & Catalog node IDs wrapped around \\
12 & 0x00001000 & Software lock \\
\textbf{13} & \textbf{0x00002000} & \textbf{Volume is journaled} \\
14 & 0x00004000 & Reserved \\
15 & 0x00008000 & Reserved \\
16-31 & 0xFFFF0000 & Reserved \\
\bottomrule
\caption{Volume Header attributes Bit Definitions}
\end{longtable}

\textbf{Common values}:
\begin{itemize}
    \item \texttt{0x00000100}: Clean, non-journaled (mkfs.hfs+ default)
    \item \texttt{0x00002100}: Clean, journaled (mkfs.hfs+ -j)
\end{itemize}

\textbf{Byte representation for 0x00000100}:
\begin{verbatim}
Offset 1028: 0x00
Offset 1029: 0x00
Offset 1030: 0x01
Offset 1031: 0x00
\end{verbatim}

\textbf{Verification}:
\begin{verbatim}
xxd -s 1028 -l 4 -p volume.hfsplus
Expected: 00000100 (non-journaled) or 00002100 (journaled)
\end{verbatim}

\subsubsection{blockSize - Allocation Block Size (Offset +40, 4 bytes)}

\textbf{Value}: 32-bit unsigned, big-endian

\textbf{Valid range}:
\begin{itemize}
    \item Minimum: 512 bytes
    \item Maximum: Typically 32 KB, theoretically larger
    \item Must be power of 2
    \item Must be multiple of 512
\end{itemize}

\textbf{Example for 4096 bytes (4 KB)}:
\begin{verbatim}
Decimal: 4096
Hex: 0x00001000
Bytes at offset 1064:
  0x00 0x00 0x10 0x00
\end{verbatim}

\textbf{Validation}:
\begin{verbatim}
xxd -s 1064 -l 4 -p volume.hfsplus
# For 4 KB blocks: 00001000
# For 8 KB blocks: 00002000
\end{verbatim}

\subsubsection{rsrcClumpSize and dataClumpSize (Offsets +56, +60)}

\textbf{Critical}: These MUST be non-zero in valid HFS+ volumes.

\textbf{Recommended value}:
\begin{equation}
\text{clumpSize} = \text{blockSize} \times 4
\end{equation}

For 4 KB blocks:
\begin{equation}
\text{clumpSize} = 4096 \times 4 = 16384 \text{ bytes} = \texttt{0x00004000}
\end{equation}

\textbf{Byte representation}:
\begin{verbatim}
rsrcClumpSize at offset 1080: 0x00 0x00 0x40 0x00
dataClumpSize at offset 1084: 0x00 0x00 0x40 0x00
\end{verbatim}

\textbf{Common error}: If these are 0x00000000, the Volume Header is invalid and nextCatalogID appears at wrong offset.

\textbf{Verification}:
\begin{verbatim}
xxd -s 1080 -l 4 -p volume.hfsplus  # rsrcClumpSize
xxd -s 1084 -l 4 -p volume.hfsplus  # dataClumpSize
# Both should be non-zero
\end{verbatim}

\subsubsection{nextCatalogID - Next CNID (Offset +64, 4 bytes)}

\textbf{Minimum}: \texttt{0x00000010} (16 decimal)

\textbf{Reserved CNIDs 1-15}:
\begin{longtable}{lp{8cm}}
\toprule
\textbf{CNID} & \textbf{Purpose} \\
\midrule
\endhead
1 & Root folder's parent (kHFSRootParentID) \\
2 & Root folder (kHFSRootFolderID) \\
3 & Extents overflow file (kHFSExtentsFileID) \\
4 & Catalog file (kHFSCatalogFileID) \\
5 & Bad allocation blocks file (kHFSBadBlockFileID) \\
6 & Allocation bitmap file (kHFSAllocationFileID) \\
7 & Startup file (kHFSStartupFileID) \\
8 & Attributes file (kHFSAttributesFileID) \\
9-13 & Reserved \\
14 & Journal file (kHFSJournalFileID, if journaled) \\
15 & Journal info block (kHFSJournalInfoBlockID) \\
\bottomrule
\caption{Reserved HFS+ Catalog Node IDs}
\end{longtable}

\textbf{Byte representation for value 16}:
\begin{verbatim}
Offset 1088: 0x00
Offset 1089: 0x00
Offset 1090: 0x00
Offset 1091: 0x10
\end{verbatim}

\textbf{Critical validation}:
\begin{verbatim}
xxd -s 1088 -l 4 -p volume.hfsplus
Expected: 00000010 (minimum value)
\end{verbatim}

\textbf{Common error}: If you see \texttt{00000000}, rsrcClumpSize/dataClumpSize were likely omitted, shifting all subsequent fields.

\subsection{HFSPlusForkData Structure - 80 Bytes Per Fork}

Each fork descriptor is 80 bytes:

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Description} \\
\midrule
\endhead
+0 & logicalSize & File size in bytes (uint64) \\
+8 & clumpSize & Clump size for this file (uint32) \\
+12 & totalBlocks & Total allocation blocks (uint32) \\
+16 & extents[0] & First extent descriptor (8 bytes) \\
+24 & extents[1] & Second extent descriptor (8 bytes) \\
+32 & extents[2] & Third extent descriptor (8 bytes) \\
+40 & extents[3] & Fourth extent descriptor (8 bytes) \\
+48 & extents[4] & Fifth extent descriptor (8 bytes) \\
+56 & extents[5] & Sixth extent descriptor (8 bytes) \\
+64 & extents[6] & Seventh extent descriptor (8 bytes) \\
+72 & extents[7] & Eighth extent descriptor (8 bytes) \\
\bottomrule
\caption{HFSPlusForkData Structure (80 bytes)}
\end{longtable}

\subsubsection{HFSPlusExtentDescriptor - 8 Bytes Each}

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Description} \\
\midrule
\endhead
+0 & startBlock & First allocation block (uint32) \\
+4 & blockCount & Number of blocks (uint32) \\
\bottomrule
\caption{HFSPlusExtentDescriptor (8 bytes)}
\end{longtable}

\textbf{Example}: Catalog file uses blocks 100-199:
\begin{verbatim}
logicalSize:  0x0000000000018800  (100 KB)
clumpSize:    0x00004000          (16 KB)
totalBlocks:  0x00000019          (25 blocks)
extents[0]:   startBlock=100, blockCount=25
              Bytes: 00 00 00 64 00 00 00 19
extents[1-7]: startBlock=0, blockCount=0 (unused)
\end{verbatim}

\subsection{Alternate Volume Header Location}

\textbf{Exact formula}:
\begin{equation}
\text{alt\_VH\_offset} = \text{volume\_size\_bytes} - 1024
\end{equation}

\textbf{Same as HFS}. This is \textbf{NOT} sector-based.

\textbf{Example for 50 MB}:
\begin{verbatim}
Volume size: 52,428,800 bytes
Alt VH at:   52,428,800 - 1,024 = 52,427,776 bytes
\end{verbatim}

\textbf{Verification}:
\begin{verbatim}
FILESIZE=$(stat -c%s volume.hfsplus)
ALTOFFSET=$((FILESIZE - 1024))
xxd -s $ALTOFFSET -l 2 -p volume.hfsplus
Expected: 482b (same as primary)
\end{verbatim}

\section{HFS+ B-Trees - Complete Node and Record Structures}

HFS+ uses B-trees for \textbf{all metadata organization}: Catalog, Extents, Attributes.

\subsection{B-Tree Node Structure - 14-Byte Node Descriptor}

\textbf{Every B-tree node begins with a 14-byte descriptor}:

\begin{longtable}{llllp{5cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Type} & \textbf{Size} & \textbf{Description} \\
\midrule
\endhead
+0 & fLink & uint32 & 4 & Forward link (next node, 0 = none) \\
+4 & bLink & uint32 & 4 & Backward link (prev node, 0 = none) \\
+8 & kind & int8 & 1 & Node type (see below) \\
+9 & height & uint8 & 1 & Level in tree (0 = leaf) \\
+10 & numRecords & uint16 & 2 & Number of records in node \\
+12 & reserved & uint16 & 2 & Reserved (must be 0) \\
\bottomrule
\caption{BTNodeDescriptor (14 bytes)}
\end{longtable}

\subsubsection{kind - Node Type Values}

\begin{longtable}{lp{8cm}}
\toprule
\textbf{Value} & \textbf{Node Type} \\
\midrule
\endhead
-1 & Leaf node (contains data records) \\
0 & Index node (contains child pointers) \\
1 & Header node (B-tree metadata, always node 0) \\
2 & Map node (allocation bitmap) \\
\bottomrule
\caption{B-tree Node Types}
\end{longtable}

\textbf{Byte example for header node (kind=1)}:
\begin{verbatim}
Offset +8: 0x01 (header node)
Offset +9: 0x00 (height 0, not used in header)
Offset +10-11: 0x00 0x03 (3 records typical: header, user data, map)
\end{verbatim}

\subsection{BTHeaderRec - B-Tree Header Record (106 Bytes)}

Located in the \textbf{first record of node 0 (header node)} in every B-tree.

\begin{longtable}{llllp{5cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Type} & \textbf{Size} & \textbf{Description} \\
\midrule
\endhead
+0 & treeDepth & uint16 & 2 & Current depth (1 = only root) \\
+2 & rootNode & uint32 & 4 & Root node number \\
+6 & leafRecords & uint32 & 4 & Total leaf records \\
+10 & firstLeafNode & uint32 & 4 & First leaf node number \\
+14 & lastLeafNode & uint32 & 4 & Last leaf node number \\
+18 & nodeSize & uint16 & 2 & Node size in bytes \\
+20 & maxKeyLength & uint16 & 2 & Maximum key length \\
+22 & totalNodes & uint32 & 4 & Total nodes allocated \\
+26 & freeNodes & uint32 & 4 & Number of free nodes \\
+30 & reserved1 & uint16 & 2 & Reserved \\
+32 & clumpSize & uint32 & 4 & Clump size for B-tree file \\
+36 & btreeType & uint8 & 1 & B-tree type (0=HFS, 128=HFS+) \\
+37 & keyCompareType & uint8 & 1 & Key comparison type \\
+38 & attributes & uint32 & 4 & B-tree attributes (flags) \\
+42 & reserved3 & uint32[16] & 64 & Reserved (must be 0) \\
\bottomrule
\caption{BTHeaderRec Structure (106 bytes total)}
\end{longtable}

\textbf{Total size verification}: 2 + 4 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 4 + 1 + 1 + 4 + 64 = 106 bytes

\subsubsection{Critical BTHeaderRec Field Details}

\textbf{treeDepth} (Offset +0):
\begin{itemize}
    \item Value 0: Empty tree
    \item Value 1: Only root node (contains data directly)
    \item Value 2+: Root is index node
    \item \textbf{New volume}: Usually 1 (minimal tree)
\end{itemize}

\textbf{nodeSize} (Offset +18):
\begin{itemize}
    \item \textbf{HFS+ Standard}: 4096 bytes (4 KB)
    \item \textbf{HFS+ Large}: 8192 bytes (8 KB)
    \item Must be power of 2
    \item Must be $\geq$ 512 bytes
\end{itemize}

\textbf{Byte representation for 4096}:
\begin{verbatim}
Offset +18: 0x10
Offset +19: 0x00
(Big-endian: 0x1000 = 4096)
\end{verbatim}

\textbf{btreeType} (Offset +36):
\begin{itemize}
    \item \textbf{0}: HFS B-tree (legacy)
    \item \textbf{128}: HFS+ B-tree (standard)
    \item \textbf{255}: Reserved
\end{itemize}

\textbf{keyCompareType} (Offset +37):
\begin{itemize}
    \item \textbf{0xBC}: Case-insensitive (HFS+ default)
    \item \textbf{0xCF}: Binary compare (HFSX case-sensitive)
\end{itemize}

\textbf{attributes} (Offset +38, 4 bytes):
\begin{longtable}{llp{7cm}}
\toprule
\textbf{Bit} & \textbf{Hex Mask} & \textbf{Meaning} \\
\midrule
\endhead
0 & 0x00000001 & Bad close (B-tree not closed properly) \\
1 & 0x00000002 & Big keys (key length $>$ 255 bytes) \\
2 & 0x00000004 & Variable index keys \\
3-31 & 0xFFFFFFF8 & Reserved (must be 0) \\
\bottomrule
\caption{BTHeaderRec attributes Flags}
\end{longtable}

\subsection{Catalog File B-Tree - Complete Key and Record Formats}

The Catalog File contains \textbf{all files and folders}. It uses \textbf{Unicode HFSUniStr255 keys}.

\subsubsection{HFSPlusCatalogKey - Variable Length}

\begin{longtable}{llllp{5cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Type} & \textbf{Size} & \textbf{Description} \\
\midrule
\endhead
+0 & keyLength & uint16 & 2 & Total key length (excluding this field) \\
+2 & parentID & uint32 & 4 & Parent folder CNID \\
+6 & nodeName & HFSUniStr255 & var & Unicode filename (see below) \\
\bottomrule
\caption{HFSPlusCatalogKey Structure}
\end{longtable}

\subsubsection{HFSUniStr255 - Unicode String (Max 255 UTF-16 Characters)}

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Description} \\
\midrule
\endhead
+0 & length & uint16: Number of UTF-16 characters (NOT bytes) \\
+2 & unicode & uint16[]: UTF-16BE characters \\
\bottomrule
\caption{HFSUniStr255 Structure}
\end{longtable}

\textbf{Example}: Filename "Test.txt" (8 characters)
\begin{verbatim}
length:  0x0008 (8 UTF-16 chars)
unicode: 
  0x0054 ('T')
  0x0065 ('e')
  0x0073 ('s')
  0x0074 ('t')
  0x002E ('.')
  0x0074 ('t')
  0x0078 ('x')
  0x0074 ('t')
Total: 2 + (8*2) = 18 bytes for nodeName
\end{verbatim}

\textbf{Complete catalog key for "Test.txt" in root (CNID 2)}:
\begin{verbatim}
keyLength: 0x0016 (22 bytes: 4 parentID + 18 nodeName)
parentID:  0x00000002 (root folder)
nodeName:  [18 bytes as shown above]
Total key: 2 + 22 = 24 bytes
\end{verbatim}

\subsubsection{Catalog Record Types - 4 Types}

\begin{longtable}{llp{7cm}}
\toprule
\textbf{Type} & \textbf{Value} & \textbf{Description} \\
\midrule
\endhead
kHFSPlusFolderRecord & 0x0001 & Folder (directory) \\
kHFSPlusFileRecord & 0x0002 & File \\
kHFSPlusFolderThreadRecord & 0x0003 & Folder thread (CNID $\rightarrow$ name) \\
kHFSPlusFileThreadRecord & 0x0004 & File thread (CNID $\rightarrow$ name) \\
\bottomrule
\caption{Catalog Record Type Values}
\end{longtable}

\subsubsection{HFSPlusCatalogFile - File Record (248 Bytes)}

\begin{longtable}{llllp{5cm}}
\toprule
\textbf{Offset} & \textbf{Field} & \textbf{Type} & \textbf{Size} & \textbf{Description} \\
\midrule
\endhead
+0 & recordType & int16 & 2 & \textbf{0x0002} (file) \\
+2 & flags & uint16 & 2 & File flags \\
+4 & reserved1 & uint32 & 4 & Reserved \\
+8 & fileID & uint32 & 4 & Catalog Node ID (CNID) \\
+12 & createDate & uint32 & 4 & Creation date (HFS+ time) \\
+16 & contentModDate & uint32 & 4 & Content modification date \\
+20 & attributeModDate & uint32 & 4 & Attribute modification date \\
+24 & accessDate & uint32 & 4 & Last access date \\
+28 & backupDate & uint32 & 4 & Backup date \\
+32 & permissions & HFSPlusBSDInfo & 16 & BSD ownership/permissions \\
+48 & userInfo & FInfo & 16 & Finder user info \\
+64 & finderInfo & FXInfo & 16 & Finder extended info \\
+80 & textEncoding & uint32 & 4 & Text encoding hint \\
+84 & reserved2 & uint32 & 4 & Reserved \\
+88 & dataFork & HFSPlusForkData & 80 & Data fork descriptor \\
+168 & resourceFork & HFSPlusForkData & 80 & Resource fork descriptor \\
\bottomrule
\caption{HFSPlusCatalogFile Structure (248 bytes total)}
\end{longtable}

\textbf{Total size verification}: 2 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 16 + 16 + 16 + 4 + 4 + 80 + 80 = 248 bytes

\subsection{Catalog File}

The Catalog File is a B-tree containing all files and folders on the volume.

\subsubsection{Catalog Keys}
\begin{itemize}
    \item \textbf{keyLength}: 2 bytes
    \item \textbf{parentID}: 4 bytes (Parent folder CNID)
    \item \textbf{nodeName}: Variable-length Unicode string
\end{itemize}

\subsubsection{Catalog Record Types}
\begin{enumerate}
    \item \textbf{Folder Record (0x0001)}: Directory metadata
    \item \textbf{File Record (0x0002)}: File metadata and fork information
    \item \textbf{Folder Thread (0x0003)}: Maps CNID to parent folder
    \item \textbf{File Thread (0x0004)}: Maps file CNID to parent folder
\end{enumerate}

\subsubsection{File Record Structure}
\begin{itemize}
    \item recordType: 0x0002
    \item flags: File flags
    \item fileID: Catalog Node ID
    \item createDate, modifyDate: Timestamps
    \item permissions: Unix permissions
    \item userInfo, finderInfo: Finder metadata
    \item textEncoding: Filename encoding hint
    \item dataFork: Fork data for data fork (80 bytes)
    \item resourceFork: Fork data for resource fork (80 bytes)
\end{itemize}

\subsection{Extents Overflow File}

B-tree storing additional extent records when a file's fork exceeds the 8 extents stored in the catalog.

\subsubsection{Extent Key}
\begin{itemize}
    \item keyLength: 2 bytes
    \item forkType: 0x00 (data) or 0xFF (resource)
    \item fileID: Catalog Node ID
    \item startBlock: Starting allocation block
\end{itemize}

\subsubsection{Extent Descriptor}
\begin{itemize}
    \item startBlock: Starting allocation block (4 bytes)
    \item blockCount: Number of contiguous blocks (4 bytes)
\end{itemize}

\subsection{Attributes File}

B-tree storing extended attributes (metadata) for files and folders.

\subsubsection{Supported Attributes}
\begin{itemize}
    \item Extended attributes (xattrs)
    \item Access Control Lists (ACLs)
    \item Resource fork data (if not inline)
    \item Compressed data (HFS+ compression)
\end{itemize}

\begin{enumerate}
    \item fsck.hfs+ detects journal
    \item Scans journal for uncommitted transactions
    \item Replays committed but unapplied transactions
    \item Marks volume clean
\end{enumerate}

\subsection{Linux Compatibility Warning}

\textbf{CRITICAL}: The Linux HFS+ kernel driver does NOT support journaling.

\begin{itemize}
    \item Journaled volumes may mount read-only automatically
    \item Journal changes are ignored
    \item Risk of data corruption on unclean shutdown
    \item fsck.hfs+ can replay journal, but Linux won't maintain it
\end{itemize}

\textbf{Recommendation}: For Linux systems, create HFS+ volumes without journaling (omit \texttt{-j} option in mkfs.hfs+).

\section{Date Representation}

HFS+ uses 32-bit unsigned integers for dates:
\begin{center}
\textbf{Seconds since January 1, 1904 00:00:00 GMT}
\end{center}

\subsection{Y2K40 Problem}

Maximum date with 32-bit unsigned:
\begin{equation}
1904 + \frac{2^{32}}{365.25 \times 24 \times 3600} \approx \text{February 6, 2040}
\end{equation}

\textbf{Implementation}: hfsutils uses \texttt{hfs\_get\_safe\_time()} to ensure dates stay within valid range.

\section{Unicode Filenames}

HFS+ stores filenames as UTF-16 (fully decomposed).

\subsection{Normalization}

HFS+ uses a special Unicode normalization similar to NFD:
\begin{itemize}
    \item Fully decomposed (e.g., é → e + combining acute)
    \item Case-insensitive comparison (HFS+) or case-sensitive (HFSX)
    \item Maximum 255 UTF-16 code units
\end{itemize}

\subsection{Character Restrictions}

Filenames cannot contain:
\begin{itemize}
    \item Colon (:) - path separator
    \item NULL character
\end{itemize}

\section{HFS+ vs HFSX}

HFSX is a variant of HFS+ with case-sensitive filename comparison.

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Feature} & \textbf{HFS+} & \textbf{HFSX} \\
\midrule
Signature & 0x482B ('H+') & 0x4858 ('HX') \\
Version & 4 & 5 \\
Case sensitivity & No & Yes \\
Filename comparison & Case-insensitive & Case-sensitive \\
"File.txt" = "file.txt" & Yes & No \\
\bottomrule
\end{tabular}
\caption{HFS+ vs HFSX}
\end{table}

\textbf{Note}: hfsutils mkfs.hfs+ creates standard HFS+ volumes (case-insensitive). HFSX support is not currently implemented.

\section{Compatibility Considerations}

\subsection{macOS}
\begin{itemize}
    \item Native support for HFS+ and HFSX
    \item Full journaling support
    \item All extended attributes supported
    \item APFS is now default (macOS 10.13+)
\end{itemize}

\subsection{Linux}
\begin{itemize}
    \item Kernel module \texttt{hfsplus} required
    \item \textbf{No journaling support in kernel driver}
    \item Basic read/write support
    \item Some extended attributes supported
    \item May mount journaled volumes read-only for safety
\end{itemize}

\subsection{FreeBSD/OpenBSD/NetBSD}
\begin{itemize}
    \item Native HFS+ read support
    \item Write support via FUSE
    \item No journaling support
\end{itemize}

\subsection{Windows}
\begin{itemize}
    \item No native HFS+ support
    \item Third-party drivers available (Paragon, MacDrive)
    \item Boot Camp drivers provide read-only access
\end{itemize}
