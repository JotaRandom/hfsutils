\chapter{Appendix}

\section{C Structure Definitions}

\subsection{HFS Master Directory Block}
\begin{verbatim}
struct HFSMasterDirectoryBlock {
    uint16_t  drSigWord;      // 0x4244
    uint32_t  drCrDate;       // Creation date
    uint32_t  drLsMod;        // Last mod date
    uint16_t  drAtrb;         // Attributes
    uint16_t  drNmFls;        // File count
    uint16_t  drVBMSt;        // Bitmap start block
    uint16_t  drAllocPtr;     // Alloc search start
    uint16_t  drNmAlBlks;     // Total alloc blocks
    uint32_t  drAlBlkSiz;     // Alloc block size
    uint32_t  drClpSiz;       // Clump size
    uint16_t  drAlBlSt;       // First alloc block
    uint32_t  drNxtCNID;      // Next CNID
    uint16_t  drFreeBks;      // Free blocks
    uint8_t   drVN[28];       // Volume name (Pascal)
    // ... (total 162 bytes)
} __attribute__((packed));
\end{verbatim}

\subsection{HFS+ Volume Header}
\begin{verbatim}
struct HFSPlusVolumeHeader {
    uint16_t  signature;           // 0x482B or 0x4858
    uint16_t  version;             // 4 or 5
    uint32_t  attributes;          // Volume attributes
    uint32_t  lastMountedVersion;  // OS signature
    uint32_t  journalInfoBlock;    // Journal block (or 0)
    uint32_t  createDate;          // HFS+ time
    uint32_t  modifyDate;
    uint32_t  backupDate;
    uint32_t  checkedDate;
    uint32_t  fileCount;
    uint32_t  folderCount;
    uint32_t  blockSize;           // Bytes
    uint32_t  totalBlocks;
    uint32_t  freeBlocks;
    uint32_t  nextAllocation;
    uint32_t  rsrcClumpSize;
    uint32_t  dataClumpSize;
    uint32_t  nextCatalogID;       // >= 16
    uint32_t  writeCount;
    uint64_t  encodingsBitmap;
    uint32_t  finderInfo[8];
    HFSPlusForkData allocationFile;  // 80 bytes each
    HFSPlusForkData extentsFile;
    HFSPlusForkData catalogFile;
    HFSPlusForkData attributesFile;
    HFSPlusForkData startupFile;
} __attribute__((packed));  // 512 bytes total
\end{verbatim}

\subsection{HFS+ Fork Data}
\begin{verbatim}
struct HFSPlusForkData {
    uint64_t  logicalSize;        // File size in bytes
    uint32_t  clumpSize;
    uint32_t  totalBlocks;
    HFSPlusExtentDescriptor extents[8];  // 8 x 8 bytes
} __attribute__((packed));  // 80 bytes total

struct HFSPlusExtentDescriptor {
    uint32_t  startBlock;
    uint32_t  blockCount;
} __attribute__((packed));  // 8 bytes
\end{verbatim}

\subsection{B-Tree Node Descriptor}
\begin{verbatim}
struct BTNodeDescriptor {
    uint32_t  fLink;       // Forward link
    uint32_t  bLink;       // Backward link
    int8_t    kind;        // -1=leaf, 0=index, 1=header, 2=map
    uint8_t   height;      // 0 for leaves
    uint16_t  numRecords;
    uint16_t  reserved;
} __attribute__((packed));  // 14 bytes
\end{verbatim}

\subsection{B-Tree Header Record}
\begin{verbatim}
struct BTHeaderRec {
    uint16_t  treeDepth;
    uint32_t  rootNode;
    uint32_t  leafRecords;
    uint32_t  firstLeafNode;
    uint32_t  lastLeafNode;
    uint16_t  nodeSize;        // Usually 4096
    uint16_t  maxKeyLength;
    uint32_t  totalNodes;
    uint32_t  freeNodes;
    uint16_t  reserved1;
    uint32_t  clumpSize;
    uint8_t   btreeType;       // 0=HFS, 128=HFS+
    uint8_t   keyCompareType;  // 0xBC or 0xCF
    uint32_t  attributes;
    uint32_t  reserved3[16];
} __attribute__((packed));  // 106 bytes
\end{verbatim}

\subsection{HFS+ Catalog File Record}
\begin{verbatim}
struct HFSPlusCatalogFile {
    int16_t   recordType;      // 0x0002
    uint16_t  flags;
    uint32_t  reserved1;
    uint32_t  fileID;          // CNID
    uint32_t  createDate;
    uint32_t  contentModDate;
    uint32_t  attributeModDate;
    uint32_t  accessDate;
    uint32_t  backupDate;
    HFSPlusBSDInfo permissions;
    FInfo     userInfo;
    FXInfo    finderInfo;
    uint32_t  textEncoding;
    uint32_t  reserved2;
    HFSPlusForkData dataFork;
    HFSPlusForkData resourceFork;
} __attribute__((packed));  // 248 bytes
\end{verbatim}

\section{Error Codes}

\subsection{mkfs Exit Codes}
\begin{longtable}{lp{10cm}}
\toprule
\textbf{Code} & \textbf{Meaning} \\
\midrule
\endhead
0 & Success \\
1 & Failure (any error) \\
\bottomrule
\caption{mkfs.hfs/mkfs.hfs+ Exit Codes}
\end{longtable}

\subsection{fsck Exit Codes}
\begin{longtable}{lp{10cm}}
\toprule
\textbf{Code} & \textbf{Meaning} \\
\midrule
\endhead
0 & No errors \\
1 & Errors corrected \\
2 & Errors corrected, reboot needed \\
4 & Errors uncorrected \\
8 & Operational error \\
16 & Usage error \\
32 & Canceled \\
128 & Library error \\
\bottomrule
\caption{fsck.hfs/fsck.hfs+ Exit Codes (BSD Standard)}
\end{longtable}

\subsection{mount Exit Codes}
\begin{longtable}{lp{10cm}}
\toprule
\textbf{Code} & \textbf{Meaning} \\
\midrule
\endhead
0 & Success \\
1 & Incorrect invocation \\
2 & System error \\
32 & Mount failure \\
\bottomrule
\caption{mount.hfs/mount.hfs+ Exit Codes}
\end{longtable}

\section{Glossary}

\begin{description}
    \item[Allocation Block] Fundamental unit of disk space allocation in HFS/HFS+. Size ranges from 512 bytes to 64 KB.
    \item[Alternate MDB/VH] Backup copy of Master Directory Block or Volume Header located at end of volume (offset: size - 1024 bytes).
    \item[B-tree] Balanced tree data structure used for catalog, extents, and attributes files.
    \item[Big-Endian] Byte order where most significant byte comes first. Used by HFS/HFS+ (Motorola format).
    \item[Catalog] B-tree containing all files and folders on volume. CNID 4 in HFS+.
    \item[CNID] Catalog Node ID - unique identifier for each file/folder. Reserved: 1-15, first user: 16.
    \item[Extent] Contiguous range of allocation blocks. Described by startBlock + blockCount.
    \item[Fork] Part of a file. HFS+  supports data fork and resource fork (80 bytes each in catalog).
    \item[HFSUniStr255] Unicode string format: 2-byte length + up to 255 UTF-16BE characters. MUST be NFD normalized.
    \item[Journal] Transaction log for crash recovery. Optional in HFS+. NOT supported by Linux kernel driver.
    \item[MDB] Master Directory Block - main metadata structure for HFS Classic. 162 bytes at offset 1024.
    \item[NFD] Normalization Form D (Decomposed) - required Unicode form for HFS+ filenames. Example: Ã© = e + combining acute.
    \item[Pascal String] Length-prefixed string (1 byte length + characters). Used in HFS for volume names.
    \item[Volume Header] Main metadata structure for HFS+. 512 bytes at offset 1024. Contains all filesystem parameters.
    \item[Y2K28] HFS Classic date overflow on February 6, 2028 (32-bit seconds since 1904).
    \item[Y2K40] HFS+ date overflow on February 6, 2040 (32-bit seconds since 1904).
\end{description}

\section{References}

\subsection{Primary Sources}
\begin{enumerate}
    \item \textbf{Apple Technical Note TN1150} - "HFS Plus Volume Format"
    \item \textbf{Inside Macintosh: Files} - Original HFS specification
    \item \textbf{Linux Kernel Source} - fs/hfs/ and fs/hfsplus/ drivers
    \item \textbf{FreeBSD Source} - sys/fs/hfs/
\end{enumerate}

\subsection{This Documentation}
This manual provides complete bit-level specifications enabling reimplementation without external references. Required external resources:
\begin{itemize}
    \item Unicode NFD decomposition tables (standard Unicode data)
    \item B-tree algorithms (standard CS textbook)
    \item CRC32 implementation (standard algorithm)
\end{itemize}

\textbf{Internet NOT required} for implementation after obtaining these standard resources.

\subsection{Online Resources (Optional)}
\begin{itemize}
    \item \url{https://developer.apple.com/legacy/library/technotes/tn/tn1150.html}
    \item Linux kernel documentation: Documentation/filesystems/hfsplus.txt
    \item Unicode tables: \url{https://unicode.org/Public/UNIDATA/}
\end{itemize}

\section{Version History}

\textbf{hfsutils 4.1.0A.2}:
\begin{itemize}
    \item Complete LaTeX documentation (this manual)
    \item Chapters 00-10: ~5,000 lines of bit-level specifications
    \item mkfs, fsck, mount, hfsutil fully documented
    \item Zero internet dependency for reimplementation
\end{itemize}
