\chapter{Implementation Details}

\section{Source Code Organization}

\subsection{Directory Structure}
\begin{verbatim}
hfsutils/
├── src/
│   ├── common/          # Shared utilities
│   │   ├── hfstime.c    # Time conversion
│   │   ├── endian.h     # Endian handling
│   │   └── version.c    # Version info
│   ├── mkfs/            # Filesystem creation
│   │   ├── mkfs_hfs.c   # HFS creator
│   │   └── mkfs_hfsplus.c # HFS+ creator
│   ├── fsck/            # Filesystem checker
│   │   ├── fsck_hfs.c
│   │   ├── fsck_hfsplus.c
│   │   ├── btree.c      # B-tree validation
│   │   └── journal.c    # Journal replay
│   ├── mount/           # Mount helpers
│   │   ├── mount_hfs.c
│   │   └── mount_hfsplus.c
│   └── hfsutil/         # HFS utilities
│       ├── hformat.c
│       ├── hmount.c
│       └── hcopy.c
├── test/                # Test suite
│   ├── test_mkfs.sh
│   ├── test_fsck.sh
│   └── test_hfsutils.sh
└── doc/                 # Documentation
    ├── man/
    └── latex/
\end{verbatim}

\section{Critical Algorithms}

\subsection{B-Tree Traversal}
\begin{verbatim}
void traverse_btree(BTNodePtr node, int depth) {
    if (node->kind == kBTLeafNode) {
        validate_leaf_records(node);
        return;
    }
    
    for (int i = 0; i < node->numRecords; i++) {
        BTNodePtr child = read_child_node(node, i);
        traverse_btree(child, depth + 1);
    }
}
\end{verbatim}

\subsection{Extent Allocation}
\begin{verbatim}
int allocate_extents(VolumePtr vol, uint32_t blocks_needed, 
                      HFSPlusExtentRecord extents) {
    uint32_t blocks_found = 0;
    uint32_t start_block = vol->nextAllocation;
    
    while (blocks_found < blocks_needed) {
        uint32_t contig = find_contiguous_blocks(vol, start_block);
        if (contig == 0) return -1; // No space
        
        add_extent(extents, start_block, contig);
        blocks_found += contig;
        start_block += contig;
    }
    
    return 0;
}
\end{verbatim}

\subsection{Unicode NFD Normalization}
\begin{verbatim}
void normalize_to_nfd(uint16_t *unicode, size_t *length) {
    for (size_t i = 0; i < *length; i++) {
        uint16_t ch = unicode[i];
        const DecompEntry *decomp = lookup_decomp(ch);
        
        if (decomp) {
            // Replace with decomposed form
            memmove(&unicode[i+decomp->count], &unicode[i+1],
                    (*length - i - 1) * sizeof(uint16_t));
            memcpy(&unicode[i], decomp->chars,
                   decomp->count * sizeof(uint16_t));
            *length += (decomp->count - 1);
            i += (decomp->count - 1);
        }
    }
}
\end{verbatim}

\section{Data Structure Handling}

\subsection{Endianness Conversion}
\begin{verbatim}
#define be16toh(x) ntohs(x)
#define be32toh(x) ntohl(x)
#define htobe16(x) htons(x)
#define htobe32(x) htonl(x)

void read_volume_header(int fd, HFSPlusVolumeHeader *vh) {
    lseek(fd, 1024, SEEK_SET);
    read(fd, vh, sizeof(*vh));
    
    // Convert all multi-byte fields
    vh->signature = be16toh(vh->signature);
    vh->version = be16toh(vh->version);
    vh->attributes = be32toh(vh->attributes);
    vh->blockSize = be32toh(vh->blockSize);
    vh->totalBlocks = be32toh(vh->totalBlocks);
    // ... convert all other fields
}
\end{verbatim}

\subsection{Memory Safety}
\begin{itemize}
    \item All buffers bounds-checked
    \item No use-after-free (valgrind verified)
    \item No memory leaks in normal operation
    \item Defensive programming throughout
\end{itemize}

\section{Performance Optimizations}

\begin{itemize}
    \item Bitmap operations use bitwise ops
    \item B-tree nodes cached during traversal
    \item Extent descriptors packed efficiently
    \item Minimal syscalls (buffered I/O)
\end{itemize}
